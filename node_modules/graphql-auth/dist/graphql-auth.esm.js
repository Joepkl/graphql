function validateScope(required, provided) {
  var hasScope = false;
  required.forEach(function (scope) {
    provided.forEach(function (providedScope) {
      // user:* -> user:create, user:view:self
      var regex = new RegExp('^' + providedScope.replace('*', '.*') + '$');

      if (regex.exec(scope)) {
        hasScope = true;
      }
    });
  });
  return hasScope;
}

function withAuth(scope, callback) {
  var next = callback ? callback : scope;
  return function (_, __, context, info) {
    try {
      var _temp5 = function _temp5(_result) {
        return _exit2 ? _result : next(_, __, context, info);
      };

      var _exit2 = false;
      // will hold resolved scope, if any
      var finalScope; // if no auth object on context in resolver, error out

      if (!context.auth) {
        return Promise.resolve(new Error('`auth` property not found on context!'));
      } // if user is not authenticated, error out


      if (!context.auth.isAuthenticated) {
        return Promise.resolve(new Error('Not authenticated!'));
      } // determine if we need to check scopes


      var hasScope = !!callback;

      var _temp6 = function () {
        if (hasScope) {
          var _temp7 = function _temp7() {
            if (finalScope && finalScope.length) {
              if (!context.auth.scope || !validateScope(finalScope, context.auth.scope)) {
                _exit2 = true;
                return new Error('Permission denied!');
              }
            }
          };

          var _temp8 = function () {
            if (typeof scope === 'function') {
              // we wrap the function in a promise so whether scope resolver is async or not we can handle it like it is
              return Promise.resolve(Promise.resolve(function () {
                return scope(_, __, context, info);
              })).then(function (_Promise$resolve) {
                finalScope = _Promise$resolve;
              });
            } else {
              finalScope = scope;
            }
          }();

          // check if scope is a function that resolves to required scopes
          return _temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8);
        }
      }();

      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

export default withAuth;
//# sourceMappingURL=graphql-auth.esm.js.map
