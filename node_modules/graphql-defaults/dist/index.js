"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genGraphQLDefaults = exports.genTypesDefinitionsMaps = exports.resetToDefaults = exports.hasDefault = exports.getDefault = exports.isDefault = exports.mergeWithDefaults = exports.graphQLDefaultsVueMixin = exports.genGqlDefaults = exports.genGraphqlDefaults = exports.genDefaults = exports.defaults = void 0;
// import { FormattedExecutionResult } from 'graphql/execution/execute';
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const nullfined_1 = __importDefault(require("nullfined"));
const freeze_object_1 = __importDefault(require("freeze-object"));
const dot = __importStar(require("dot-wild"));
const lodash_1 = __importDefault(require("lodash"));
const { forEach, has, get } = dot;
const { isEmpty, isNil, merge, cloneDeep, isEqual, isObject, set, camelCase } = lodash_1.default;
// todo use this as enums
exports.defaults = {
    'ID': null,
    'Int': 0,
    'Float': 0.0,
    'Long': 0,
    'String': '',
    'Boolean': false,
    'DateTime': '',
    'Date': '',
    'Time': '',
    'JSON': null,
};
const TypesMaps = {};
let Schema;
let SchemaByTypeName;
exports.graphQLDefaultsVueMixin = {
    // don't use this as defaults itself will be part of data, unless you want to only host graphql defaults in $gqlDefaults
    data() {
        // console.debug(`[index]-40: graphqlDefaults data() - `, this.$options.name);
        return {
            $gqlDefaults: {},
        };
    },
    methods: {
        // @ts-ignore todo
        $genDefaults: genGraphQLDefaults,
        // @ts-ignore todo
        $genGraphqlDefaults: genGraphQLDefaults,
        // @ts-ignore todo
        $genGraphQLDefaults: genGraphQLDefaults,
        $mergeWithDefaults: mergeWithDefaults,
        $isDefault: isDefault,
        $resetToDefaults: resetToDefaults,
        $getDefault: getDefault,
        $hasDefault: hasDefault,
    },
};
/** default export - the object is used in functions below, mainly to access the debug var */
const GraphqlDefaults = {
    genTypesDefinitionsMaps,
    graphQLDefaultsVueMixin: exports.graphQLDefaultsVueMixin,
    genDefaults: genGraphQLDefaults,
    genGraphqlDefaults: genGraphQLDefaults,
    genGqlDefaults: genGraphQLDefaults,
    genGraphQLDefaults,
    mergeWithDefaults,
    isDefault,
    resetToDefaults,
    getDefault,
    hasDefault,
    defaults: exports.defaults,
    debug: false,
};
exports.default = GraphqlDefaults;
/**
 * merge the given data to the component data path using defaults
 * @example mergeWithDefaults({ path: 'key.path', data })
 *
 * @returns {*}
 */
function mergeWithDefaults({ path, operation, data, defaults, 
// @ts-ignore todo
context = this, debug = GraphqlDefaults.debug, }) {
    if (!defaults) {
        // get defaults specific to the path key
        if (!!path) {
            defaults = get(context.$gqlDefaults || context, path);
        }
        if (!defaults && !!operation) {
            // destructure the object and drop the key (unknown path to defaults)
            // @ts-ignore todo
            defaults = genGraphQLDefaults({ operation, context, debug });
            if (!!path)
                defaults = lodash_1.default.get(defaults, path, defaults);
        }
        if (!path && !defaults) {
            throw new Error(`[graphql-defaults]-75: Undefined path, defaults, or operation (to generate defaults from, or operation didn't generate defaults as expected)!`);
        }
    }
    //make sure defaults are a deep clone
    defaults = cloneDeep(defaults);
    if (debug > 1) {
        console.debug(`[graphql-defaults]-82: mergeWithDefaults() - path: %o\n - context: %o\n- defaults: %o`, path, context, cloneDeep(defaults));
    }
    // use isUndefined coz data maybe null if record wasn't found for instance
    if (lodash_1.default.isUndefined(data)) {
        data = context[path];
    }
    if (debug > 1) {
        console.debug(`[graphql-defaults]-90: mergeWithDefaults() - to merge with: %o`, cloneDeep(data));
    }
    if (!defaults) {
        throw new Error(`[graphql-defaults]-101: Unable to get defaults for key path: "${path}"! \nPlease check your path argument to $mergeWithDefaults \nor make sure "context.${path}" exists and optionally initialised by eg:\n "context.${path} = $genGraphQLDefaults(${path}Query).${camelCase(path)}" in "vm's created()" hook.`);
    }
    // use isUndefined coz data maybe null if record wasn't found for instance
    if (lodash_1.default.isUndefined(data)) {
        throw new Error(`[graphql-defaults]-105: Unable to get data for key path: "${path}" on context! \nPlease check your path argument to $mergeWithDefaults \nor make sure "vm.$data.${path}" exists \nor provide the data object eg: "${camelCase(path)} = $mergeWithDefaults('${path}', dataObj)".`);
    }
    data = (0, nullfined_1.default)(data);
    if (debug > 1) {
        console.debug(`[graphql-defaults]-111: mergeWithDefaults() - data: %o after nullfining.`, cloneDeep(data));
    }
    // just check if data is empty, it means it's just a complete replace of it by defaults
    if (isEmpty(data)) {
        return defaults;
    }
    // we need to take care of a situation whereby defaults with the following structure
    // [{...}] are being merged with data that has the following structure
    // [{...},{...},{...}] A direct merge simply merges the first elements of data that
    // correspond to their default counterparts.
    // However, each of the obj in the data array should be merged with defaults obj and
    // this should be done deeply, that's if there are some more records like this
    // (eg: nested relationships that have multiple records)
    // then it should fix them as well
    // Wildcard path. Start with the shallowest part of the path
    let wPath = '*';
    // data = merge(defaults, data);
    // console.debug(`[graphql-defaults]-109: mergeWithDefaults() - data: %o`, data);
    // return data;
    // Clone the data obj. This makes it faster and much cleaner to iterate a temporary obj instead of the one we are mutating
    let dataTmp = cloneDeep(data);
    data = assign(defaults, data);
    // see if we can get anything at this path level
    while (has(defaults, wPath)) {
        // todo iterate thru defaults instead, this removes the missing defaults error and other code, but introduces a loop for arrays
        // iterate thru each prop at wPath depth
        forEach(dataTmp, wPath, 
        /**
         *
         * @param _val {*} - property value at path
         * @param key {String} - property key at path
         * @param ctx {Object} - context obj whose properties are being iterated. not using it
         * @param cPath {String} - path, complete path at current wildcard path in the prop iteration
         */
        (_val, key, ctx, cPath) => {
            if (key === '__typename') {
                return;
            }
            // isolate the value from dataTmp so we don't mutate it (mutate the data obj only... see below)
            let v = cloneDeep(_val);
            // Get the defaults prop cPath. Modify cPath so that we only have the first elements at whatever def level of cPath. This will map directly to the defaults that have arrays;
            let _defaultPath = cPath
                .replace(/^[0-9]*$/g, '0') // only index
                .replace(/^[0-9]*\./g, '0.') // first level indexes
                .replace(/\.[0-9]*\./g, '.0.') // middle level indexes
                .replace(/\.[0-9]*$/g, '.0'); // last level indexes
            // Get the default using defaultPath
            let _default = lodash_1.default.get(defaults, _defaultPath);
            if (debug && lodash_1.default.isUndefined(_default)) {
                console.warn(`[graphql-defaults]-140: Ignoring property: '${_defaultPath}' - Couldn't get property defaults from generated defaults:\n %o.\nProperty was probably injected into the provided data and is not in original query that created those defaults. Use mergeWithDefaults before injecting property into data.`, defaults);
            }
            if (debug > 1) {
                console.debug(`\n-----------------\nv: %o, \nkey: %o, \ncPath: %o, \nctx: %o`, v, key, cPath, ctx);
                console.debug(`[graphql-defaults]-147: () - ctx[k]: %o`, cloneDeep(ctx[key]));
                console.debug(`\n_default: %o, _defaultPath: %o`, _default, _defaultPath);
            }
            const r = assign(_default, v);
            if (!r)
                return;
            else
                v = r;
            // Now finalise the merge by mutating the data property at cPath with v
            // @ts-ignore todo
            data = set(data, cPath, v);
            if (debug > 1) {
                console.debug(`[graphql-defaults]-173: - cPath final \nctx[key]: %o, \nv: %o, \nget(data, cPath): %o, \ndata: %o \n**********************\n`, cloneDeep(ctx[key]), cloneDeep(v), cloneDeep(get(data, cPath)), cloneDeep(data));
            }
        });
        // increase depth
        wPath += '.*';
    }
    // console.debug(`merged with defaults results: " %o "`, data);
    if (debug > 1) {
        console.debug(`\n[graphql-defaults]-196: - merged with defaults results data: %o \n###########################\n`, cloneDeep(data));
    }
    // comment on release
    if (process.env.NODE_ENV !== 'production') {
        // clone the results so that we don't get false info at debugging (this has been a headache where the app/test mutates the result downstream)
        return cloneDeep(data);
    }
    // none-debug optimized mode, just return the data without cloning it
    return data;
}
exports.mergeWithDefaults = mergeWithDefaults;
/**
 * Merge default with v at key of cPath into data
 * @param _default
 * @param v
 * @return {*}
 */
function assign(_default, v) {
    // handle array and make sure both default and value are arrays and value has a length
    if (Array.isArray(_default) && Array.isArray(v) && v.length) {
        // cache the default for mapping below
        const _def = cloneDeep(_default[0]);
        // go thru each value element and merge with default
        v = v.map(vd => merge(_def, vd));
    }
    else if (isObject(_default)) {
        // if default is an object (applies to either array or plain object). Complete previous strict condition on arrays and handle objs
        v = merge(cloneDeep(_default), v);
    }
    else if (isNil(v)) {
        // if value is undefined or null, then assign the default value
        v = _default;
    }
    else {
        // scalar value, leave as is
        return;
    }
    return v;
}
/**
 * Check if the prop value at specified path is a default
 * @param path {string}
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {boolean}
 */
// @ts-ignore todo
function isDefault(path, context = this) {
    return isEqual(get(context.$gqlDefaults || context, path), isObject(path) ? path : get(context, path));
}
exports.isDefault = isDefault;
/**
 * Get the default for specified path
 * @param path {string|object} - if omitted it will return the entire defaults obj for context
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {Object} - the default object at key path
 */
// @ts-ignore todo
function getDefault(path, context = this) {
    if (isObject(path)) {
        context = path;
        path = undefined;
    }
    if (!context) {
        throw new Error(`[graphql-defaults]-217: Cannot getDefault from undefined context!`);
    }
    if (!!path) {
        // noinspection JSCheckFunctionSignatures
        return cloneDeep(get(context.$gqlDefaults || context, path));
    }
    else {
        return cloneDeep(context.$gqlDefaults || context);
    }
}
exports.getDefault = getDefault;
/**
 * Check if context has defaults for specified path
 * @param path {string}
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {Boolean} - if context has defaults at key path
 */
// @ts-ignore todo
function hasDefault(path, context = this) {
    if (!!path) {
        return !!getDefault(path, context);
    }
    else {
        throw new Error(`[graphql-defaults]-271: Cannot hasDefault without path!`);
    }
}
exports.hasDefault = hasDefault;
/**
 * reset the specified prop at key to it's initial values when component was created
 * @param path {string|object} - prop path on context obj eg: 'thing' === this.thing. if no key is specified it resets the entire component's data props
 * @param context {Object}: where to find the $gqlDefaults object
 */
// @ts-ignore todo
function resetToDefaults(path, context = this) {
    if (isObject(path)) {
        context = path;
        path = undefined;
    }
    if (!!path) {
        set(context, path, getDefault(path, context));
    }
    else {
        if (context.$data) {
            context.$data = getDefault(path, context);
        }
        else {
            merge(context, getDefault(path, context));
        }
    }
}
exports.resetToDefaults = resetToDefaults;
/**
 * check if the given definition is in exclusion array
 * @param {ObjectTypeDefinitionNode} def
 * @param {any[]} exclude
 * @return {boolean}
 */
function matchExclusion(def, exclude) {
    return exclude.some((ex) => def.name.value.match(new RegExp(ex)));
}
/**
 * Make types definition and map their defaults
 * @param schema
 * @param exclude {Array<String|RegExp>} - a list of regex to match with type definitions names to skip. this causes any type that match this regexes to be skipped
 */
function genTypesDefinitionsMaps(schema, exclude = []) {
    var _a;
    if (typeof schema === 'string') {
        try {
            schema = (0, graphql_tag_1.default) `${schema}`;
        }
        catch (e) {
            console.error(e);
            throw new Error(`[graphql-defaults]-264: Schema must be a valid AST GraphQL schema with type definitions: `);
        }
    }
    if (!Array.isArray(schema.definitions) || !lodash_1.default.get(schema, 'definitions.length')) {
        throw new Error(`[graphql-defaults]-269: Schema doesn't have any type definitions: `);
    }
    Schema = schema;
    // just store the definition by type name for easier associations
    SchemaByTypeName = Schema.definitions
        // the filter maybe useless, but maybe out there, there are rogue ones without this
        // and may cause an error later downstream
        .filter((def) => !!def.name)
        .map((def) => {
        return { [def.name.value]: def };
    });
    // console.debug(`[graphql-defaults]-274: SCHEMA: `, Schema);
    // console.debug(`[graphql-defaults]-286: genTypesDefinitionsMaps() - SchemaByTypeName: %o`, SchemaByTypeName);
    // console.debug(`[graphql-defaults]-273: keys SCHEMA: `, _.uniq(schema.definitions.map(d=>d.kind)));
    // console.debug(`[graphql-defaults]-275: SCHEMA: `, get(schema.definitions.filter(d=>d.kind==='ObjectTypeDefinition'),'*.fields.*.name.value'));
    // console.debug(`[graphql-defaults]-330: SCHEMA definitions: `, schema.definitions.filter(d=>d.kind==='ObjectTypeDefinition'));
    // let definitions = [];
    for (let i = 0; i < Schema.definitions.length; i++) {
        let def = Schema.definitions[i];
        // skip those that don't have a name
        if (!def.name)
            continue;
        // skip type definition if it matches excluded type definitions regex
        if (matchExclusion(def, exclude))
            continue;
        // console.debug(`[graphql-defaults]-298: genTypesDefinitionsMaps() - def: %o`, def.name);
        // console.debug(`[graphql-defaults]-300: genTypesDefinitionsMaps() - def:`);
        // console.dir(def, { depth: 2 });
        // console.debug(`_____________________________________
        // [graphql-defaults]-303: genTypesDefinitionsMaps() - def kind: %o name: %o`, def.kind, def.name.value);
        // todo handle morph types (polymorphic relations), skipping them for now
        if (def.name.value === 'Query'
            ||
                def.name.value === 'Mutation'
            ||
                def.name.value === 'Subscription') {
            // defer these for later processing since all these depend on basic type definitions
            for (let fi = 0; fi < ((_a = def.fields) === null || _a === void 0 ? void 0 : _a.length); fi++) {
                let field = def.fields[fi];
                if (matchExclusion(field, exclude))
                    continue;
                // definitions.push(field);
                // let's do this later after creating basic type definitions
                addDefToTypesMaps(field, exclude);
            }
        }
        else if (def.kind === 'ScalarTypeDefinition') {
            /**
             * cater for new SCALAR types
             */
            // do not redefine the scalar default if it already exists
            if (!lodash_1.default.has(exports.defaults, def.name.value)) {
                // todo I am not sure about how scalars get their types in AST
                let kind = get(def, 'description.kind', '').replace('Value', '');
                let _default = get(def, 'description.default');
                // console.debug(`[graphql-defaults]-339: ScalarTypeDefinition def: %o, kind: %o`, def, kind);
                // console.debug(`[graphql-defaults]-340: genTypesDefinitionsMaps() - defaults: %o`, defaults);
                // @ts-ignore todo
                exports.defaults[def.name.value] = _default || !!kind && !!exports.defaults[kind] ? exports.defaults[kind] : '';
            }
            // noinspection UnnecessaryContinueJS just to be sure we don't exec anything else
            continue;
        }
        else { //if (def.kind === 'ObjectTypeDefinition') {
            // todo morph / UnionTypeDefinition???
            /**
             * cater for OBJECT types definitions
             */
            addDefToTypesMaps(def, exclude);
        }
    }
    console.debug(`[index/genTypesDefinitionsMaps()]-619: defaults: %o`, exports.defaults);
    /** add fields or mark as scalar to TypesMaps that refer to other type maps Queries, Mutations and Subscriptions */
    for (const type in TypesMaps) {
        const typeMap = TypesMaps[type];
        typeMap.isScalar = false;
        if (lodash_1.default.isEmpty(typeMap.fields) && lodash_1.default.isUndefined(typeMap.types)) {
            // @ts-ignore
            const default_ = exports.defaults[typeMap.type];
            /** check to see if this is a scalar */
            if (!lodash_1.default.isUndefined(default_)) {
                typeMap.kind = typeMap.type;
                typeMap.isScalar = true;
                typeMap.default = default_;
                continue;
            }
            let tmwf = TypesMaps[typeMap.type];
            let typeMapWithFields = tmwf;
            let times = 0;
            /** search for the last referred type */
            /*while (!!tmwf) {
             // todo fix this
              tmwf = TypesMaps[tmwf?.type];
              typeMapWithFields = tmwf;
              if (times++ > 100) throw new Error(`[index/genTypesDefinitionsMaps()]-622: Possible infinite loop detected between types: ${tmwf?.type} that refer themselves in a loop!`);
            }*/
            // todo this is crying on morphs and EnumTypeDefinition
            // if (!typeMapWithFields?.fields) console.warn(`[index/genTypesDefinitionsMaps()]-617: missing fields for last typeMap definition for: "${typeMap.type}"  referred from typeMap: "${type}"`);
            typeMap.fields = typeMapWithFields === null || typeMapWithFields === void 0 ? void 0 : typeMapWithFields.fields;
        }
    }
    console.debug(`[graphql-defaults]-489:: TYPES DEFINITIONS: `, TypesMaps);
}
exports.genTypesDefinitionsMaps = genTypesDefinitionsMaps;
/**
 * add the given type definition to TypesMaps
 * @param {ObjectTypeDefinitionNode} def
 * @param exclude {string[]}
 */
function addDefToTypesMaps(def, exclude) {
    var _a;
    /** make fields */
    const fields = ((_a = def.fields) !== null && _a !== void 0 ? _a : []).reduce((accum, field) => {
        if (matchExclusion(field, exclude))
            return accum;
        if (TypesMaps[def.name.value])
            throw new Error(`[graphql-defaults/addDefToTypesMaps()]-527: TypeMap: "${def.name.value}" was already defined!`);
        let fieldTypeKind = getTypeName(field);
        const type = fieldTypeKind;
        let isScalar = lodash_1.default.has(exports.defaults, fieldTypeKind);
        let kind = getTypeKind(field);
        // todo check if the field schema has a default set and use that instead of inferring from the type, it seems like gql doesn't have a field default
        // @ts-ignore todo
        let _default = exports.defaults[fieldTypeKind];
        if (!isScalar) {
            let tnk = get(SchemaByTypeName, `*.${type}.kind`);
            kind = getTypeMapKind(field);
            // console.debug(`[graphql-defaults]-393: genTypesDefinitionsMaps() - tnk: %o, kind: %o`, tnk, kind, );
            if (!!tnk && tnk[0] === 'EnumTypeDefinition') {
                // todo i think enum types should default to its first value entry????
                // console.debug(`[graphql-defaults]-396: genTypesDefinitionsMaps() - setting enumtype def props for field: %o`, field);
                kind = 'String';
                isScalar = true;
                _default = exports.defaults['String'];
            }
        }
        // kind = fieldTypeKind;
        // console.debug(`[graphql-defaults]-407: genTypesDefinitionsMaps() - defaults[${fTypeName}]: %o, _default: %o`, defaults[fTypeName], _default);
        // console.debug(`[graphql-defaults]-408: genTypesDefinitionsMaps() - ${field.name.value} field: %o , ftk: %o, isScalar: %o, fTypeName: %o`, field, ftk, isScalar, fTypeName);
        // create the field
        // @ts-ignore todo
        accum[field.name.value] = {
            type,
            kind,
            isScalar,
            default: _default,
            definition: field,
        };
        return accum;
    }, {});
    TypesMaps[def.name.value] = Object.assign(Object.assign(Object.assign(Object.assign({ type: getTypeName(def) }, (!lodash_1.default.isEmpty(def.types) ? { types: def.types } : {})), { 
        // @ts-ignore
        kind: def.kind === 'EnumTypeDefinition' ? 'String' : getTypeMapKind(def) }), (!lodash_1.default.isEmpty(fields) ? { fields } : {})), { definition: def });
}
/**
 * return scalar defaults based on the given query
 * @param operation {Object}
 * @param context {object}
 * @param path {string}
 * @param populateListTypes {boolean}
 * @param genTypename {boolean}
 * @param debug {number}
 * @returns {*}
 */
function genGraphQLDefaults({ operation, 
// @ts-ignore todo
context = this, path, populateListTypes = true, genTypename = true, debug = GraphqlDefaults.debug, }) {
    // TODO use caches to cache operation and fragmentsMaps for faster execution
    if (isEmpty(TypesMaps)) {
        throw new Error(`[graphql-defaults]-505: No types definitions found, you must initialize with genTypesDefinitionsMaps(schema) first to create required types!`);
    }
    if (typeof operation === 'string') {
        try {
            operation = (0, graphql_tag_1.default) `${operation}`;
        }
        catch (e) {
            console.error(e);
            throw new Error(`[graphql-defaults]-514: Query must be a valid AST GraphQL operation`);
        }
    }
    // console.debug(`[graphql-defaults]-519: genGraphQLDefaults() - operation; %o`, operation);
    // console.debug(`[graphql-defaults]-520: DEFINITIONS: `, definitions);
    let queryDefs = operation.definitions;
    // console.debug(`[graphql-defaults]-524: QUERY: `, queryDefs);
    let jsObj;
    if (!queryDefs) {
        throw new Error(NOT_AST_ERR);
    }
    else {
        // console.debug('[graphql-defaults]-530: operation selection set: ', queryDefs);
        // @ts-ignore todo
        let fragmentsMaps = genFragmentsMaps(queryDefs);
        // @ts-ignore todo
        if (!['query', 'mutation', 'subscription'].includes(queryDefs[0].operation)) {
            throw new Error(NOT_AST_ERR);
        }
        else {
            // todo get the OperationDefinition objects only instead of referencing array element 0
            // GraphQL only works with a single operation at a time; check this out:
            // https://github.com/graphql/graphql-js/issues/260
            // @ts-ignore todo
            jsObj = parseSetSelections(queryDefs[0].selectionSet.selections, undefined, fragmentsMaps, {
                populateListTypes,
                genTypename,
                debug,
            });
            if (!!context) {
                setContextDefault(context, path, jsObj);
            }
        }
    }
    // console.debug(`[index]-597: genGraphQLDefaults() - jsObj: %o`, jsObj);
    return jsObj;
}
exports.genGraphQLDefaults = genGraphQLDefaults;
exports.genDefaults = genGraphQLDefaults;
exports.genGraphqlDefaults = genGraphQLDefaults;
exports.genGqlDefaults = genGraphQLDefaults;
/**
 * set the given context's defaults based on path and value
 * @param context
 * @param path
 * @param value
 */
function setContextDefault(context, path, value) {
    // @ts-ignore todo
    let _path = path || lodash_1.default.get(Object.keys(value), '[0]');
    const _value = (0, freeze_object_1.default)(cloneDeep(lodash_1.default.get(value, _path)));
    if (lodash_1.default.get(context, '_isVue')) {
        _path = `$gqlDefaults.${_path}`;
    }
    lodash_1.default.set(context, _path, _value);
    // console.debug(`[index]-614: genGraphQLDefaults() - context: %o`, context);
}
/**
 * get object leaf value of initObj. The leaf value is obtained via valPath
 * @param initObj {object} - the initial object we are digging into
 * @param step {string} - the string to use as we go deeper into the obj
 * @param leafPath {string} - the leaf path that is used to retrieve the leaf from the obj
 * @param failPath {string} - doesn't consider Leaf that contains this as a hit
 * @return {*} - the final leaf obj or value to retrieve
 */
function getObjLeaf(initObj, step, leafPath, failPath) {
    let path = step;
    let obj, leaf;
    // get the object at current path
    while (!!(obj = get(initObj, path))) {
        // get the leaf from the current obj
        leaf = get(obj, leafPath);
        // dig deeper
        path += step;
    }
    if (!leaf)
        return get(initObj, failPath !== null && failPath !== void 0 ? failPath : leafPath);
    // return the last valid obj leaf value
    return leaf;
}
/**
 * get the type name of the given field or type
 * @param rootType
 * @returns {*}
 */
function getTypeName(rootType) {
    return getObjLeaf(rootType, '.type', 'name.value');
}
/**
 * get the type name of the given field or type
 * @param rootType
 * @returns {*}
 */
function getTypeKind(rootType) {
    return getObjLeaf(rootType, '.type', 'kind');
}
// @ts-ignore todo
function getTypeMapKind(typeMap) {
    return lodash_1.default.get(typeMap, 'type.kind', lodash_1.default.get(typeMap, 'kind')) === 'ListType' ? 'ListType' : 'Object';
}
/**
 * generate fragment maps used to parse fragments in the query
 * @param defs
 */
// todo
function genFragmentsMaps(defs) {
    let fragmentsMaps = {};
    defs.filter((qd) => qd.kind === 'FragmentDefinition').forEach((f) => 
    // @ts-ignore todo
    fragmentsMaps[f.name.value] = {
        // @ts-ignore todo
        type: f.typeCondition.name.value,
        // @ts-ignore todo
        selections: f.selectionSet.selections,
    });
    // console.debug(`FRAGMENTS: `, fragmentsMaps);
    return fragmentsMaps;
}
/**
 *
 * @param selections
 * @param parentTypeMap
 * @param fragmentsMaps
 * @param options
 */
function parseSetSelections(selections, parentTypeMap, fragmentsMaps, options) {
    let selsObj = {};
    // console.debug(`[graphql-defaults]-638: parseSetSelections() - TypesMaps: `, TypesMaps);
    // console.debug(`[index/parseSetSelections()]-798: selections: %o`, selections);
    // iterate thru
    for (let selection of selections) {
        // try {
        let selectionName = selection.name.value;
        let keyName = get(selection.alias, 'value', selectionName);
        const debug = ['' /*'contact', 'profile', 'phones', 'settings'*/].includes(keyName);
        debug && console.debug(`
===============>
[graphql-defaults]-641: parseSetSelections() - selectionName: %o, selection: %o`, selectionName, selection);
        if (selection.kind === 'FragmentSpread') {
            // handle fragment spread
            let fragment = fragmentsMaps[selectionName];
            if (!fragment)
                throw new Error(`[graphql-defaults]-647: GraphQL-Defaults: Error parsing fragment spread - Missing fragment: "${selectionName}" - Please make sure you import/include the specified missing fragment in the query being processed!`);
            // @ts-ignore todo
            let tMap = TypesMaps[fragment.type];
            selsObj = Object.assign({}, parseSetSelections(fragment.selections, tMap, fragmentsMaps, options));
            // @ts-ignore todo
            if (options.genTypename && !isEmpty(selsObj))
                selsObj.__typename = fragment.type;
        }
        else if (selection.selectionSet !== undefined) {
            /** this is an ObjectTypeDefinition with fields*/
            // get the type map for the selection, or if this is a field aliased type then get it's type definition
            // @ts-ignore todo
            let typeMap = TypesMaps[selectionName] || get(parentTypeMap, `fields.${selectionName}`);
            debug && console.debug(`[graphql-defaults]-660: parseSetSelections() - selectionName: %o, typeMap: %o`, selectionName, typeMap);
            // this is the root selectionSet or probably some wrapper type, which doesn't have fields
            if (!typeMap) {
                const sels = get(selection, 'selectionSet.selections');
                if (sels) {
                    // we have a selections array with which we can work with, dig deeper into it
                    // @ts-ignore todo
                    selsObj[keyName] = parseSetSelections(sels, undefined, fragmentsMaps, options);
                }
                else {
                    console.debug(`[graphql-defaults]-669: selection: `, selection);
                    console.debug(`[graphql-defaults]-670: parentTypeMap: `, parentTypeMap);
                    throw new Error(`[graphql-defaults]-671: something went wrong trying to get typeMap and selectionSet selections for "${selectionName}"`);
                }
            }
            else {
                // get the actual type fields if this was some alias that we are acting on
                if (!typeMap.fields) {
                    // @ts-ignore todo
                    typeMap.fields = TypesMaps[typeMap.type].fields;
                }
                // recurse deeper in next level since this is not a scalar
                let parseResult = parseSetSelections(selection.selectionSet.selections, typeMap, fragmentsMaps, options);
                // @ts-ignore todo
                if (options.genTypename && !isEmpty(parseResult))
                    parseResult.__typename = typeMap.type;
                // now place it properly based on parent type map kind information or type map kind information
                if (getTypeMapKind(typeMap) === 'ListType') {
                    if (options.populateListTypes) {
                        // @ts-ignore todo
                        selsObj[keyName] = [parseResult];
                    }
                    else {
                        // console.debug(`[graphql-defaults]-687: parseSetSelections() - parseResult: `, parseResult);
                        // @ts-ignore todo
                        selsObj[keyName] = isEmpty(parseResult) ? [] : [parseResult];
                    }
                }
                else {
                    // @ts-ignore todo
                    selsObj[keyName] = parseResult;
                }
            }
        }
        else {
            // console.debug(`[graphql-defaults]-697:---------parentTypeMap: %o, selection: %o, selectionName: %o`, parentTypeMap, selection, selectionName);
            // handle scalar field, get it's default value and assign it if the parent type kind is an obj, anything else don't do anything, thus parentField == [] for arrays
            let pts = getParentTypeMapSelection(selectionName, parentTypeMap);
            // let ptsk = getParentTypeMapSelectionKind(selectionName, parentTypeMap);
            let ptk = getTypeMapKind(parentTypeMap);
            // console.debug(`[graphql-defaults]-704: parseSetSelections() - pts: %o, ptsk: %o, ptk: %o`, pts, ptsk, ptk);
            if (lodash_1.default.get(pts, 'isScalar')) {
                if (ptk === 'ListType' && options.populateListTypes || ptk === 'Object') {
                    // @ts-ignore todo
                    selsObj[keyName] = parentTypeMap.fields[selectionName].default;
                }
            }
        }
        // } catch (e) {
        //   console.error(`[graphql-defaults]-713: An unexpected error happened: \n\nfield def: `, selection, ` parentTypeMap: `, parentTypeMap);
        // }
    }
    return selsObj;
}
// @ts-ignore todo
function getParentTypeMapSelection(selName, typeMap) {
    // console.debug(`[graphql-defaults]-722: getParentTypeMapSelectionKind() -   typeMap: %o`, typeMap);
    return get(typeMap, `fields.${selName}`);
}
// @ts-ignore todo
function getParentTypeMapSelectionKind(selName, typeMap) {
    // console.debug(`[graphql-defaults]-728: getParentTypeMapSelectionKind() -   typeMap: %o`, typeMap);
    //return typeMap.kind === 'Object' ? 'Object' : 'ListType';
    let kind = get(getParentTypeMapSelection(selName, typeMap), `kind`);
    /*if (!kind) {
     // console.debug(`[graphql-defaults]-733: getParentTypeMapSelectionKind() - typeMap: %o`, typeMap);
     throw new Error(`[graphql-defaults]-734: unable to get "${selName}" kind for typeMap: "${get(typeMap, 'name')}". Check the selection names being requested in the query`);
     // console.warn(`[graphql-defaults]-735: unable to get "${selName}" kind for typeMap: "${get(typeMap, 'name')}". Check the selection names being requested in the query`);
     }*/
    // console.debug(`=======================[graphql-defaults]-738: getParentTypeMapSelectionKind() - "${selName}" kind: %o`, kind);
    return kind;
}
// define err messages
const NOT_AST_ERR = 'Query is not AST obj, use Graphql Tag to convert query to valid Graphql AST code.';
