import { DocumentNode } from 'graphql/language/ast';
import { FormattedExecutionResult } from 'graphql/execution/execute';

// todo should extend vue component or something
export interface iGraphQLDefaultsVueMixin extends ComponentOptions {
  data (): {
    $gqlDefaults: object;
  };
  
  methods: {
    $genDefaults: typeof genGraphQLDefaults;
    $genGraphqlDefaults: typeof genGraphQLDefaults;
    $genGraphQLDefaults: typeof genGraphQLDefaults;
    $mergeWithDefaults: typeof mergeWithDefaults;
    $isDefault: typeof isDefault;
    $resetToDefaults: typeof resetToDefaults;
    $getDefault: typeof getDefault;
    $hasDefault: typeof hasDefault;
  };
}

export interface iMergeWithDefaultsOpts {
  /** path to prop we wish to merge with data */
  path: string;
  /** @type operation Graphql operation to generate defaults from */
  operation: DocumentNode;
  /** the data to merge with defaults */
  data?: object; // todo pass type to this
  /** @param defaults defaults to use */
  defaults?: object; // todo pass type to this
  /** @type context where to find the $gqlDefaults object, defaults to this */
  context?: any; // todo pass context type to this
  debug?: number | boolean | undefined;
}


/**
 * merge the given data to the component data path using defaults
 * @example mergeWithDefaults({ path: 'key.path', data })
 *
 * @returns {*}
 */
export declare function mergeWithDefaults ({
                                             path,
                                             operation,
                                             data,
                                             defaults,
                                             context,
                                             debug,
                                           }: iMergeWithDefaultsOpts): object | undefined;

/**
 * Check if the prop value at specified path is a default
 * @param path {string}
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {boolean}
 */
export declare function isDefault (path: string, context?: any): boolean;

/**
 * Get the default for specified path
 * @param path {string|object} - if omitted it will return the entire defaults obj for context
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {Object} - the default object at key path
 */
export declare function getDefault (path?: string | object, context?: any): any;

/**
 * Check if context has defaults for specified path
 * @param path {string}
 * @param context {Object}: where to find the $gqlDefaults object
 * @returns {Boolean} - if context has defaults at key path
 */
export declare function hasDefault (path: string, context?: any): boolean;

/**
 * reset the specified prop at key to it's initial values when component was created
 * @param path {string|object} - prop path on context obj eg: 'thing' === this.thing. if no key is specified it resets the entire component's data props
 * @param context {Object}: where to find the $gqlDefaults object
 */
export declare function resetToDefaults (path?: string | object, context?: any): void;

/**
 * Make types definition and map their defaults
 * @param schema
 * @param exclude {Array<String|RegExp>} - a list of regex to match with type definitions names to skip. this causes any type that match this regexes to be skipped
 */
export declare function genTypesDefinitionsMaps (schema: DocumentNode | string, exclude?: (string | RegExp)[]): void;

interface iGenGraphQLDefaultsOpts {
  operation: DocumentNode;
  context?: any;
  path?: string;
  populateListTypes?: boolean;
  genTypename?: boolean;
  debug?: number | boolean | undefined;
}

/**
 * return scalar defaults based on the given query
 * @param operation {Object}
 * @param context {object}
 * @param path {string|undefined}
 * @param populateListTypes {boolean}
 * @param genTypename {boolean}
 * @param debug {number}
 * @returns {*}
 */
export declare function genGraphQLDefaults ({ operation, context, path, populateListTypes, genTypename, debug }: iGenGraphQLDefaultsOpts): object;
